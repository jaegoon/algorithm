---
title : 알고리즘 공부 : 다이나믹 프로그래밍 유형 정리
date : 

----

### 유형1 : Assembly-line scheduling
공장에서 제품을 생산하는 과정에서 N개의 공정이 있고, 각 공정을 처리할 수 있는 라인이 K개 있다.
각 라인마다 다른 공정 비용을 가지고 있,고 라인을 변경해서 공정을 처리할 경우에도 다른 공정 비용이 발생한다.
이 때, 제품 생산하는데 다는 최소 비용을 구하는 문제이다.

memo[i][j] 를 i번째 공정을 j라인으로 처리한 이후 부터 발생하는 모든 공정 비용의 최소값을 저장하여
DFS 알고리즘과 메모이제이션을 이용하면 쉽게 접근할 수 있다.
N번째 공정까지 도달해야 실제 최소 비용인지 알 수 있기 때문에 DFS를 이용한다.



### 유형 2 : Rod cutting
길이가 N인 막대기를 여러 나무조각으로 잘라서 판매한다.
이때 길이마다 판매가격이 다를때, 최대 수익을 내는 방법을 구하는 문제이다.
넣을 수 있는 물건의 무게가 한정된 배낭에 물건의 종류마다 개수가 무한인 Unbounded Knapsack 문제 유형과 비슷한 것 같다.
다른 점은 막대기는 모든 조각을 팔아야 하지만, 배낭은 조금 덜 채워도 되는 점 정도인 것 같다. 

암튼,
dp[n]을 길이가 n인 막대기를 가지고 낼 수 있는 최대 수익으로 정의하고
길이 1~N인 막대기를 모든 경우의 조각으로 잘라봤을 때 나올 수 있는 최대값을 dp에 저장하면 된다.
dp[n] = for(i=1~n, max(dp[n], dp[n-i]+p[i]))




### 유형 3 : Longest Increasing Subsequence (최대 부분 증가 수열)
주어진 수열 내에서 증가하는 부분 수열을 구하되, 길이가 가장 긴 부분 수열을 구하는 문제 유형이다.
예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 가 주어질 경우,
LIS 는 {10, 20, 30, 50}이고, 길이는 4이다.

O(N^2) 방법이 일반적이지만, 더 복잡한 문제를 해결하기 위한 O(NlogN) 시간복잡도 방법도 있다.
여기선 O(N^2) 방법을 알아보겠다.

DP를 이용하면 꽤 간단하다.
dp[i]는 수열의 i번째 수가 마지막 원소일때 가질 수 있는 LIS 길이로 정의하고
2중 for문을 통해 i = 1~N 까지 채워나가면 된다.
for(i = 1 ~ N){
	dp[i] = 1; // 초기화도 중요하다.
	for(k = 1 ~ i보다 작은 수){
		dp[i] = max(dp[k]+1)
	}
}

백준에서 관련 문제는 다음과 같다.
1965번. 상자넣기
2352번. 반도체 설계
11053번. 가장 긴 증가하는 부분 수열 
11054번. 가장 긴 바이토닉 부분 수열
...



### 유형 4 :  0/1 Knapsack
넣을 수 있는 물건의 무게가 한정된 배낭에 물건의 종류마다 개수가 1개인 Knapsack 문제이다.
이때 물건마다 무게와 가치가 다를때, 배낭에 담을 수 있는 물건의 가치 합계의 최대값을 구하는 문제이다.

모든 경우의 수를 체크해보되, 메모이제이션을 통해 시간을 줄여야 한다.
dp[w][n] 를 무게 제한이 w이고 1~n번째 물건까지 배낭에 넣을지 고려할 경우 가질 수 있는 물건 가치 합의 최대값으로 정의하고
무게 제한을 1부터 시작해 1씩 늘리고, 각 무게 제한마다 모든 종류의 물건을 넣어보면서 dp[W][N]을 채워나간다.
for(무게제한 w=1~W)
	for(물건 종류 n=1~N) dp[w][n] = max(dp[w][n], dp[w-w[i]][n] + v[i])



### 유형 5 : Matrix-chain multiplication (연쇄 행렬 곱셈)

	

백준에서 관련 문제는 다음과 같다.
11049 행렬 곱셈 순서
11066